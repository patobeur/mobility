<!DOCTYPE html>
<html lang="fr">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Three.js – Avatar GLTF top‑down</title>
		<style>
			html,
			body {
				height: 100%;
				margin: 0;
				background: #111;
				color: #eee;
				font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
					Cantarell, Noto Sans, sans-serif;
			}
			#app {
				position: fixed;
				inset: 0;
			}
			#hud {
				position: fixed;
				left: 12px;
				top: 12px;
				background: rgba(0, 0, 0, 0.55);
				backdrop-filter: blur(4px);
				border: 1px solid #333;
				border-radius: 12px;
				padding: 10px 12px;
				min-width: 260px;
				box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
			}
			#hud h1 {
				margin: 0 0 6px 0;
				font-size: 14px;
				font-weight: 700;
				letter-spacing: 0.4px;
				color: #cdd;
			}
			#hud .bar {
				height: 10px;
				background: #333;
				border-radius: 999px;
				overflow: hidden;
				margin: 6px 0 10px;
			}
			#hud .bar > span {
				display: block;
				height: 100%;
				width: 0%;
				background: linear-gradient(90deg, #ff4d4d, #ffb199);
			}
			#hud .bar.xp > span {
				background: linear-gradient(90deg, #4da3ff, #b1e0ff);
			}
			#hud .stats {
				font-size: 12px;
				color: #c8d1da;
				line-height: 1.25;
			}
			#hud kbd {
				background: #222;
				border: 1px solid #444;
				border-bottom-color: #333;
				padding: 2px 6px;
				border-radius: 6px;
				font-size: 11px;
			}
			#hud .anim {
				margin-top: 8px;
				font-size: 12px;
				color: #9ec;
			}
			#hud .anims-list {
				margin-top: 4px;
				font-size: 11px;
				color: #aab;
				max-height: 88px;
				overflow: auto;
			}
			#help {
				position: fixed;
				right: 12px;
				top: 12px;
				color: #9aa;
				font-size: 12px;
				background: rgba(0, 0, 0, 0.45);
				border: 1px solid #333;
				border-radius: 10px;
				padding: 8px 10px;
			}
			canvas {
				display: block;
			}
		</style>
	</head>
	<body>
		<div id="app"></div>
		<div id="hud">
			<h1>Avatar GLTF — Top‑down</h1>
			<div class="stats">Vie: <span id="lifeVal">100</span> / 100</div>
			<div class="bar"><span id="lifeBar"></span></div>
			<div class="stats">XP: <span id="xpVal">0</span></div>
			<div class="bar xp"><span id="xpBar"></span></div>
			<div class="stats">Anim: <strong id="animName">(aucune)</strong></div>
			<div class="anim"
				>Actions: <kbd>↑↓←→</kbd>/<kbd>ZQSD</kbd> marcher;
				<kbd>Shift</kbd> courir; <kbd>Espace</kbd> sauter;
				<kbd>Ctrl</kbd> action; Clic gauche: destination; Souris: oriente le
				perso.</div
			>
			<div class="anims-list" id="animsList"></div>
		</div>
		<div id="help">Help info !</div>
		<script type="importmap">
			{
				"imports": {
					"three": "/node_modules_min/three/build/three.module.js",
					"three/addons/": "/node_modules_min/three/examples/jsm/"
				}
			}
		</script>

		<script src="/node_modules_min/three/examples/jsm/libs/ammo.wasm.js"></script>
		<script type="module">
			import * as THREE from "three";
			import { GLTFLoader } from "/node_modules_min/three/examples/jsm/loaders/GLTFLoader.js";
			import { OrbitControls } from "/node_modules_min/three/examples/jsm/controls/OrbitControls.js";
			window.addEventListener("load", () => {
				// if (SOCKET) {
				if (THREE) {
					if (Ammo) {
						Ammo().then(() => {
							console.log({ Ammo: Ammo });
						});
					}
				}
				// }
			});

			// --- Rendu de base
			const app = document.getElementById("app");
			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			app.appendChild(renderer.domElement);

			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0x0b0b0f);

			const camera = new THREE.PerspectiveCamera(
				55,
				window.innerWidth / window.innerHeight,
				0.1,
				2000
			);
			const camRig = new THREE.Object3D();
			scene.add(camRig);
			camRig.position.set(0, 0, 0);

			camera.position.set(0, 30, 15); // hauteur
			camera.rotation.order = "YXZ";
			camera.rotation.set(-Math.PI / 3, 0, 0); // regarde vers le bas
			camRig.add(camera);
			// Lumières
			const hemi = new THREE.HemisphereLight(0xffffff, 0x333344, 0.6);
			scene.add(hemi);
			const sun = new THREE.DirectionalLight(0xffffff, 0.8);
			sun.position.set(30, 60, 10);
			sun.castShadow = true;
			scene.add(sun);

			// --- Sol: damier noir&blanc + GridHelper
			const SIZE = 500,
				TILE = 2; // 500x500m, carreaux 2m
			function makeCheckerTexture(size = 512, squares = 16) {
				const c = document.createElement("canvas");
				c.width = c.height = size;
				const ctx = c.getContext("2d");
				const step = size / squares;
				for (let y = 0; y < squares; y++) {
					for (let x = 0; x < squares; x++) {
						ctx.fillStyle = (x + y) % 2 === 0 ? "#222" : "#ddd";
						ctx.fillRect(x * step, y * step, step, step);
					}
				}
				return new THREE.CanvasTexture(c);
			}
			const checker = makeCheckerTexture(1024, Math.floor(SIZE / TILE));
			checker.wrapS = checker.wrapT = THREE.RepeatWrapping;
			checker.repeat.set(SIZE / TILE, SIZE / TILE);

			const groundMat = new THREE.MeshStandardMaterial({
				map: checker,
				metalness: 0.0,
				roughness: 1.0,
			});
			const ground = new THREE.Mesh(
				new THREE.PlaneGeometry(SIZE, SIZE),
				groundMat
			);
			ground.rotation.x = -Math.PI / 2;
			ground.receiveShadow = true;
			scene.add(ground);

			const grid = new THREE.GridHelper(
				SIZE,
				SIZE / TILE,
				0x666666,
				0x444444
			);
			scene.add(grid);

			// --- Raycaster pour la souris
			const raycaster = new THREE.Raycaster();
			const mouse = new THREE.Vector2();

			// --- Joueur
			const player = {
				root: new THREE.Group(),
				model: null,
				mixer: null,
				actions: {},
				clips: [],
				speed: 6, // m/s marche
				runMult: 1.8,
				y: 0,
				vy: 0,
				onGround: true,
				life: 100,
				lifeMax: 100,
				xp: 0,
				level: 1,
				dest: null,
				facing: 0,
				moving: false,
				lastPlayed: null,
			};
			player.root.position.set(0, 0, 0);
			scene.add(player.root);

			// --- UI helpers
			const $lifeBar = document.getElementById("lifeBar");
			const $lifeVal = document.getElementById("lifeVal");
			const $xpBar = document.getElementById("xpBar");
			const $xpVal = document.getElementById("xpVal");
			const $anim = document.getElementById("animName");
			const $anims = document.getElementById("animsList");

			function updateHUD() {
				$lifeVal.textContent = Math.round(player.life);
				$lifeBar.style.width =
					((100 * player.life) / player.lifeMax).toFixed(1) + "%";
				$xpVal.textContent = Math.floor(player.xp);
				const xpPct = player.xp % 100;
				$xpBar.style.width = xpPct + "%";
			}

			function logAnims() {
				$anims.innerHTML = player.clips.map((c) => `${c.name}`);
				// .join("<br>")
				console.log(
					"Animations GLTF:",
					player.clips.map((c) => c.name)
				);
			}

			// --- Chargement du GLTF (mettez le fichier à côté de ce HTML)
			const loader = new GLTFLoader();
			loader.load(
				"./toon/Kimono_Female.gltf",
				(gltf) => {
					player.model = gltf.scene;
					player.model.traverse((o) => {
						if (o.isMesh) {
							o.castShadow = true;
							o.receiveShadow = true;
						}
					});
					player.model.scale.set(1, 1, 1);
					player.root.add(player.model);

					// Centrage approx sur sol
					const box = new THREE.Box3().setFromObject(player.model);
					const center = new THREE.Vector3();
					box.getCenter(center);
					player.model.position.sub(center.setY(0));

					player.mixer = new THREE.AnimationMixer(player.model);
					player.clips = gltf.animations || [];
					logAnims();

					// Prépare un dictionnaire par nom normalisé
					const dict = {};
					for (const clip of player.clips) {
						dict[clip.name.toLowerCase()] = clip;
					}

					function findClip(keys) {
						const names = Object.keys(dict);
						for (const k of keys) {
							const hit = names.find((n) => n.includes(k));
							if (hit) return dict[hit];
						}
						return null;
					}

					// Heuristique: idle / walk / run / jump / action
					presets.idle =
						findClip(["idle", "breath", "stand", "pose"]) ||
						player.clips[0] ||
						null;
					presets.walk =
						findClip(["walk", "move", "locomotion"]) || presets.idle;
					presets.run = findClip(["run", "sprint"]) || presets.walk;
					presets.jump = findClip(["jump"]) || null;
					presets.action =
						findClip([
							"attack",
							"punch",
							"kick",
							"cast",
							"clap",
							"dance",
							"action",
						]) || null;

					playAction(presets.idle, 0.2, true);
					updateHUD();
				},
				undefined,
				(err) => {
					console.error(err);
					alert(
						"Impossible de charger toon/Kimono_Female.gltf — placez le fichier à côté de ce HTML."
					);
				}
			);

			const presets = {
				idle: null,
				walk: null,
				run: null,
				jump: null,
				action: null,
			};

			let currentClip = null; // ajoute en haut, à côté de presets/etat

			function playAction(clip, fade = 0.15, loop = true) {
				if (!clip || !player.mixer) return;
				if (currentClip === clip) return; // <-- garde-fou
				const prevAction = player.lastPlayed;
				const action = player.mixer.clipAction(clip);
				action.enabled = true;
				action.setLoop(loop ? THREE.LoopRepeat : THREE.LoopOnce);
				action.clampWhenFinished = !loop;

				action.reset().fadeIn(fade).play();
				if (prevAction && prevAction !== action) prevAction.fadeOut(fade);

				player.lastPlayed = action;
				currentClip = clip;
				$anim.textContent = clip.name;
			}

			// function playAction(clip, fade = 0.15, loop = true) {
			// 	if (!clip || !player.mixer) return;
			// 	const prev = player.lastPlayed;
			// 	const action = player.mixer.clipAction(clip);
			// 	action.reset();
			// 	action.setLoop(loop ? THREE.LoopRepeat : THREE.LoopOnce);
			// 	action.clampWhenFinished = !loop;
			// 	action.enable = true;
			// 	if (prev && prev !== action) {
			// 		prev.fadeOut(fade);
			// 	}
			// 	action.fadeIn(fade).play();
			// 	player.lastPlayed = action;
			// 	$anim.textContent = clip.name;
			// }

			// --- Caméra top‑down qui suit le joueur
			const camOffset = new THREE.Vector3(0, 30, 0); // au‑dessus
			const camLerp = 0.08; // tu peux garder ta valeur

			function updateCamera(dt) {
				// lerp en XZ uniquement ; Y fixé par la caméra elle-même
				const t = 1 - Math.pow(1 - camLerp, dt * 60);
				camRig.position.lerp(
					new THREE.Vector3(
						player.root.position.x,
						0,
						player.root.position.z
					),
					t
				);
				// Surtout: pas de camera.lookAt ici !
			}
			// -------------------------------
			// -------------------------------
			const ROT_SPEED = 6; // rad/s (≈ 343°/s). Diminue si tu veux plus doux.

			function shortestAngleDiff(a, b) {
				let d = (b - a + Math.PI) % (2 * Math.PI);
				if (d < 0) d += 2 * Math.PI;
				return d - Math.PI; // dans [-PI, PI]
			}

			function rotateModelTowards(targetYaw, dt) {
				if (!player.model) return;
				const cur = player.model.rotation.y;
				const diff = shortestAngleDiff(cur, targetYaw);
				const maxStep = ROT_SPEED * dt;
				const step =
					Math.abs(diff) < maxStep ? diff : Math.sign(diff) * maxStep;
				player.model.rotation.y = cur + step;
			}
			// -------------------------------
			// -------------------------------
			// --- Entrées clavier
			const keys = new Set();
			window.addEventListener("keydown", (e) => {
				keys.add(e.key.toLowerCase());
				if ([" ", "space"].includes(e.key.toLowerCase()))
					e.preventDefault();
			});
			window.addEventListener("keyup", (e) =>
				keys.delete(e.key.toLowerCase())
			);

			function axis() {
				// Flèches + ZQSD + WASD
				let x = 0,
					z = 0;
				if (keys.has("arrowup") || keys.has("z") || keys.has("w")) z -= 1;
				if (keys.has("arrowdown") || keys.has("s")) z += 1;
				if (keys.has("arrowleft") || keys.has("q") || keys.has("a")) x -= 1;
				if (keys.has("arrowright") || keys.has("d")) x += 1;
				const len = Math.hypot(x, z) || 1;
				return { x: x / len, z: z / len };
			}

			function isShift() {
				return keys.has("shift");
			}
			function isCtrl() {
				return keys.has("control");
			}
			function isSpace() {
				return keys.has(" ") || keys.has("space");
			}

			// --- Souris: orientation + clic pour destination
			function updateMouseOrientation(dt) {
				if (!player.model) return;
				raycaster.setFromCamera(mouse, camera);
				const hit = raycaster.ray.intersectPlane(
					new THREE.Plane(new THREE.Vector3(0, 1, 0), 0),
					new THREE.Vector3()
				);
				if (hit) {
					const dir = new THREE.Vector3().subVectors(
						hit,
						player.root.position
					);
					dir.y = 0;
					dir.normalize();
					if (dir.lengthSq() > 0.0001) {
						player.facing = Math.atan2(dir.x, dir.z);
						// player.model.rotation.y = player.facing;
						rotateModelTowards(player.facing, dt);
					}
				}
			}

			window.addEventListener("mousemove", (e) => {
				const rect = renderer.domElement.getBoundingClientRect();
				mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
				mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
			});

			window.addEventListener("click", (e) => {
				// Clic gauche = aller où on pointe
				raycaster.setFromCamera(mouse, camera);
				const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
				const p = new THREE.Vector3();
				if (raycaster.ray.intersectPlane(plane, p)) {
					player.dest = p.clone();
				}
			});

			// --- Boucle principale
			const clock = new THREE.Clock();

			function movePlayer(dt) {
				const ax = axis();
				const usingKeyboard = Math.abs(ax.x) + Math.abs(ax.z) > 0;

				if (player.dest && !usingKeyboard) {
					// Click‑to‑move (si pas d'input clavier)
					const to = new THREE.Vector3().subVectors(
						player.dest,
						player.root.position
					);
					to.y = 0;
					const dist = to.length();
					if (dist > 0.05) {
						to.normalize();
						player.facing = Math.atan2(to.x, to.z);
						// if (player.model) player.model.rotation.y = player.facing;
						if (player.model) rotateModelTowards(player.facing, dt);
						const spd = player.speed * (isShift() ? player.runMult : 1);
						player.root.position.addScaledVector(to, spd * dt);
						player.moving = true;
					} else {
						player.dest = null;
						player.moving = false;
					}
				} else if (usingKeyboard) {
					const dir = new THREE.Vector3(ax.x, 0, ax.z);
					const spd = player.speed * (isShift() ? player.runMult : 1);
					player.root.position.addScaledVector(dir, spd * dt);
					// Orientation = souris (prioritaire), sinon direction du déplacement
					if (player.model) {
						if (Math.abs(mouse.x) + Math.abs(mouse.y) < 1e-3) {
							player.facing = Math.atan2(dir.x, dir.z);
							// player.model.rotation.y = player.facing;
							rotateModelTowards(player.facing, dt);
						}
					}
					player.moving = true;
					player.dest = null;
				} else {
					player.moving = false;
				}

				// Saut simple (parabole)
				if (isSpace() && player.onGround) {
					player.vy = 8;
					player.onGround = false;
					if (presets.jump) playAction(presets.jump, 0.05, false);
				}
				if (!player.onGround) {
					player.vy -= 20 * dt; // gravité
					player.y += player.vy * dt;
					if (player.y <= 0) {
						player.y = 0;
						player.vy = 0;
						player.onGround = true;
					}
				}
				player.root.position.y = player.y;

				// Choix d'animation
				if (!player.onGround && presets.jump) {
					// laisser la jump jouer en LoopOnce
				} else if (isCtrl() && presets.action) {
					playAction(presets.action, 0.05, true);
					gainXP(10 * dt);
				} else if (player.moving) {
					playAction(
						isShift()
							? presets.run || presets.walk
							: presets.walk || presets.idle,
						0.1,
						true
					);
					if (isShift()) gainXP(4 * dt); // petite XP pour déplacement prolongé
				} else {
					playAction(presets.idle, 0.2, true);
				}
			}

			function gainXP(v) {
				player.xp += v;
				updateHUD();
				// exemple de level up
				if (player.xp >= player.level * 100) {
					player.level++;
					player.lifeMax += 10;
					player.life = Math.min(player.life + 20, player.lifeMax);
				}
			}

			function damage(v) {
				player.life = Math.max(0, player.life - v);
				updateHUD();
			}

			function loop() {
				const dt = Math.min(0.033, clock.getDelta());
				if (player.mixer) player.mixer.update(dt);

				updateMouseOrientation(dt);
				movePlayer(dt);
				updateCamera(dt);

				renderer.render(scene, camera);
				requestAnimationFrame(loop);
			}

			// Réactivité
			window.addEventListener("resize", () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			});

			// Démarre
			updateHUD();
			loop();

			// Expose quelques helpers pour debug dans la console
			Object.assign(window, { scene, camera, player, damage, gainXP });
		</script>
	</body>
</html>
